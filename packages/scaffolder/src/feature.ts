/* eslint-disable no-console */

import chalk from 'chalk';
import {
  existsSync,
  mkdirSync,
  readFileSync,
  writeFileSync,
} from 'fs';
import { dirname } from 'path';

import { parseExpression, parseFalsy, parseObjectExpression } from './expressions/index.js';
import { collectInputs } from './helpers.js';
import { Feature } from './types.js';
import handleError from './error.js';

/**
 * Process a feature and scaffold the files.
 */
export default async function processFeature(rootDir: string, feature: Feature) {
  const {
    config: {
      name,
      inputs: featureInputs = [],
      files: featureFiles = [],
    },
    path: featurePath,
  } = feature;

  // Prompt the user for all feature inputs.
  const inputs = await collectInputs(featureInputs);

  // The context variables passed to the expression parser.
  const expressionContext = {
    feature: {
      name,
      path: featurePath,
    },
    inputs,
  };

  // Collect the files to be generated by processing the "if" conditionals.
  const files = featureFiles
    // Parse the expression of any file attribute.
    .map((file) => parseObjectExpression({
      ...file,
      // Ensure that destination/source directories are prefixed with the
      // feature/root directories, respectively, to allow the configuration to
      // be relative from the config file.
      destination: `${rootDir}/${file.destination}`,
      source: `${featurePath}/${file.source}`,
    }, expressionContext))
    // Check if the already-parsed condition is not falsy.
    .filter(({ if: condition = null }) => condition === null || !parseFalsy(condition))
    .filter(({
      destination: destinationPath,
      source: sourcePath,
    }) => {
      // Ensure that the source exists and can be resolved.
      if (!existsSync(sourcePath)) {
        handleError(`Source file not found: ${sourcePath}`);
      }

      // Ensure that the destination does not exist.
      if (existsSync(destinationPath)) {
        handleError(`Destination file already exists: ${destinationPath}`);
      }

      return true;
    });

  if (!files.length) {
    handleError(`No files to generate for the feature ${name}`);
  }

  // Run each file through the expression parser and write the file to their new
  // file destination.
  files.forEach(async ({ destination, source }) => {
    try {
      // Read the file from the source and parse the expressions.
      const file = parseExpression(readFileSync(source, 'utf8'), expressionContext);
      const destinationDir = dirname(destination);

      // Ensure that the directory exists.
      if (!existsSync(destinationDir)) {
        mkdirSync(destinationDir, { recursive: true });
      }

      writeFileSync(destination, file);

      console.log(`${chalk.greenBright('âœ”')} Generated ${chalk.green(destination.replace(rootDir, '').replace(/^\//, ''))}`);
    } catch (error: any) {
      handleError(`Error writing from ${chalk.yellow(source)} to ${chalk.yellow(destination)}: ${chalk.white(error.message || '')}`);
    }
  });
}
